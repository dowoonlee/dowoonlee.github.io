---
title: 15829) Hashing
tags: Alogrithm boj python

---

[15829](https://www.acmicpc.net/problem/15829)

## 제목 : 스티커

- APC에 온 것을 환영한다. 만약 여러분이 학교에서 자료구조를 수강했다면 해시 함수에 대해 배웠을 것이다. 해시 함수란 임의의 길이의 입력을 받아서 고정된 길이의 출력을 내보내는 함수로 정의한다. 해시 함수는 무궁무진한 응용 분야를 갖는데, 대표적으로 자료의 저장과 탐색에 쓰인다.

  이 문제에서는 여러분이 앞으로 유용하게 쓸 수 있는 해시 함수를 하나 가르쳐주고자 한다. 먼저, 편의상 입력으로 들어오는 문자열에는 영문 소문자(a, b, ..., z)로만 구성되어있다고 가정하자. 영어에는 총 26개의 알파벳이 존재하므로 a에는 1, b에는 2, c에는 3, ..., z에는 26으로 고유한 번호를 부여할 수 있다. 결과적으로 우리는 하나의 문자열을 수열로 변환할 수 있다. 예를 들어서 문자열 "abba"은 수열 1, 2, 2, 1로 나타낼 수 있다.

  해시 값을 계산하기 위해서 우리는 문자열 혹은 수열을 하나의 정수로 치환하려고 한다. 간단하게는 수열의 값을 모두 더할 수도 있다. 해시 함수의 정의에서 유한한 범위의 출력을 가져야 한다고 했으니까 적당히 큰 수 M으로 나눠주자. 짜잔! 해시 함수가 완성되었다. 이를 수식으로 표현하면 아래와 같다.

  $$ H=\sum_{i=0}^{l-1}a_i mod M $$

  해시 함수의 입력으로 들어올 수 있는 문자열의 종류는 무한하지만 출력 범위는 정해져있다. 다들 비둘기 집의 원리에 대해서는 한 번쯤 들어봤을 것이다. 그 원리에 의하면 서로 다른 문자열이더라도 동일한 해시 값을 가질 수 있다. 이를 해시 충돌이라고 하는데, 좋은 해시 함수는 최대한 충돌이 적게 일어나야 한다. 위에서 정의한 해시 함수는 알파벳의 순서만 바꿔도 충돌이 일어나기 때문에 나쁜 해시 함수이다. 그러니까 조금 더 개선해보자.

  어떻게 하면 순서가 달라졌을때 출력값도 달라지게 할 수 있을까? 머리를 굴리면 수열의 각 항마다 고유한 계수를 부여하면 된다는 아이디어를 생각해볼 수 있다. 가장 대표적인 방법은 항의 번호에 해당하는 만큼 특정한 숫자를 거듭제곱해서 곱해준 다음 더하는 것이 있다. 이를 수식으로 표현하면 아래와 같다.

  보통 r과 M은 서로소인 숫자로 정하는 것이 일반적이다. 우리가 직접 정하라고 하면 힘들테니까 r의 값은 26보다 큰 소수인 31로 하고 M의 값은 1234567891(놀랍게도 소수이다!!)로 하자.

  이제 여러분이 할 일은 위 식을 통해 주어진 문자열의 해시 값을 계산하는 것이다. 그리고 이 함수는 간단해 보여도 자주 쓰이니까 기억해뒀다가 잘 써먹도록 하자.









- 입력 : 첫째 줄에 테스트 케이스의 개수 T가 주어진다. 각 테스트 케이스의 첫째 줄에는 n (1 ≤ n ≤ 100,000)이 주어진다. 다음 두 줄에는 n개의 정수가 주어지며, 각 정수는 그 위치에 해당하는 스티커의 점수이다. 연속하는 두 정수 사이에는 빈 칸이 하나 있다. 점수는 0보다 크거나 같고, 100보다 작거나 같은 정수이다. 
- 출력 : 각 테스트 케이스 마다, 2n개의 스티커 중에서 두 변을 공유하지 않는 스티커 점수의 최댓값을 출력한다.



비교적 간단한 DP 문제이다. 문제를 푸는 방법은 여럿일 수 있지만 난 간단한 점화식 모델을 세워서 접근했다. 이문제의 특징은 스티커를 떼어냈을 때, 주위 스티커를 사용하지 못한다는 점이다. 즉 특정 스티커 선택하기 위해서는 선결과제가 존재하고 이는 DP로 접근할 수 도 있다는 가능성을 제시한다.

2n개의 스티커에 대해서 얘기해보자. i(<n)번 째 열에 위치한 두 개의 스티커 중 위쪽 스티커를 $S_{i,0}$, 아래쪽 스티커를 $S_{i,1}$ 이라고 하자. $S_{i,0}$를 선택하기 위해서 i-1번 째 열에서 어떤 선택을 해야할까? 일단 인접한 스티커는 선택할 수 없기 때문에 $S_{i-1,0}$은 선택하지 못한다. 그렇다면? 당연히 $S_{i-1, 1}$을 선택했을 것이다. 하지만 마냥 그렇지도 않다. 문제에서 주어진 예시를 보자. 마지막 열(n)의 60을 선택하기 위해서 그 전 열(n-1)의 20을 선택했는가? 전혀. 그냥 선택하지 않고 그 열을 넘겼다. 왜냐하면 n-2번 째 열에서 100짜리 스티커를 선택해야 하기 때문이다.

즉 $S_{i,0}$를 선택하는 경우는 두 가지 접근방법이 있는데 첫 번째는 그 이전 열의 다른행 스티커 $S_{i-1, 1}$을 선택하는 것이고, 또 하나는 이전 열(i-1)을 스킵하고 그 보다 더 전 열(i-2)에서 선택하는 것이다. 후자의 경우 i-2열에서 어떤 행의 경우의 수를 따르건 상관없다(i-2에서 윗행을 고르던 아래행을 고르던 i에서 스티커를 선택하는데 문제가 없으므로 둘 다 고려해야 한다는 뜻이다).

내 코드의 경우 DP를 계산할 때 행별로 하나씩 만들어서 $2\times n$의 배열로 구성했기 때문에, 두 번째 경우의 수(i-1번 째 에서 아무것도 고르지 않은 경우) 를 모두 고려하지 않고 각 행에 대한 것만 고려하였다. 즉

`DP[0행][열] = max(DP[0행][열-1] + sticker[1행][열], DP[0행][열-1])` 

`DP[1행][열] = max(DP[1행][열-1] + sticker[0행][열], DP[1행][열-1])` 

이런식으로 둘을 동시에 고려하는 방식으로 접근하였다.



코드는 다음과 같다.

```python
import sys

t = int(sys.stdin.readline())

for _ in range(t):
    n = int(sys.stdin.readline())
    stickers = []
    for ti in range(2):
        stickers.append(list(map(int ,sys.stdin.readline().split())))
    dp = [[0]*n for _ in range(2)]
    dp[0][0], dp[1][0] = stickers[0][0], stickers[1][0]

    for i in range(1, n):
        dp[0][i] = max(dp[1][i - 1] + stickers[0][i], dp[0][i - 1])
        dp[1][i] = max(dp[0][i - 1] + stickers[1][i], dp[1][i - 1])
    max1, max2 = max(dp[0]), max(dp[1])
    print(max(max1,max2))
```





솔브닥 CLASS 4 받으려고 안푼 문제들을 풀고 있는데 뭔... 넘 어렵다. 그리고 DP는 이번 문제처럼 쉬운 문제가 아니면 점화식 파악하고 for문 돌리는데 시간이 너무 많이 소모된다. 계속 풀고 있긴한데 실력이 늘긴 느는건지...









