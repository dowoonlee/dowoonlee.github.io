---
title: 4673) 셀프 넘버
tags: Alogrithm boj python
---

[4673](https://www.acmicpc.net/problem/4673)


# 제목 : 셀프 넘버

- 문제 : 셀프 넘버는 1949년 인도 수학자 D.R. Kaprekar가 이름 붙였다. 양의 정수 n에 대해서 d(n)을 n과 n의 각 자리수를 더하는 함수라고 정의하자. 예를 들어, d(75) = 75+7+5 = 87이다.

양의 정수 n이 주어졌을 때, 이 수를 시작해서 n, d(n), d(d(n)), d(d(d(n))), ...과 같은 무한 수열을 만들 수 있다. 

예를 들어, 33으로 시작한다면 다음 수는 33 + 3 + 3 = 39이고, 그 다음 수는 39 + 3 + 9 = 51, 다음 수는 51 + 5 + 1 = 57이다. 이런식으로 다음과 같은 수열을 만들 수 있다.

33, 39, 51, 57, 69, 84, 96, 111, 114, 120, 123, 129, 141, ...

n을 d(n)의 생성자라고 한다. 위의 수열에서 33은 39의 생성자이고, 39는 51의 생성자, 51은 57의 생성자이다. 생성자가 한 개보다 많은 경우도 있다. 예를 들어, 101은 생성자가 2개(91과 100) 있다. 

생성자가 없는 숫자를 셀프 넘버라고 한다. 100보다 작은 셀프 넘버는 총 13개가 있다. 1, 3, 5, 7, 9, 20, 31, 42, 53, 64, 75, 86, 97

10000보다 작거나 같은 셀프 넘버를 한 줄에 하나씩 출력하는 프로그램을 작성하시오.


- 입력 : 입력은 없다.
- 출력 : 10,000보다 작거나 같은 셀프 넘버를 한 줄에 하나씩 증가하는 순서로 출력한다.

다른 사람들은 이 문제를 어떻게 풀었는지 모르겠다. 하지만 주어진 조건이 계산 시간 1초 / 메모리 사용량 256MB 로 굉장히 넉넉하게 주어졌기 때문에 배열을 사용하여 문제를 풀었다.
어떤 특정 수가 생성자를 가지는지를 고민하는 건 좀 어려울 수 있으나 주어진 수를 생성자로 하여 계산하는 건 어렵지 않다. (33을 생성자로 39를 만드는 건 덧셈만 할 줄 알면 간단하지만 39를 보고 33이 생성자인걸 알아내는건 고민 좀 해봐야 할 것이다)

selfnumber라는 함수를 정의하여 임의의 수 n을 받았을 때 d(n)을 리턴하도록 하였고, 그 수가 10000보다 작거나 같은 경우 미리 만들어둔 10000개 크기의 배열에서 해당 위치 원소를 True에서 False로 변경하도록 하였다.
n은 d(n)보다 무조건 작기 때문에 굳이 계산을 다하고나서 출력할 것 없이 계산과 출력을 동시에 하면된다.

각 자릿수를 더하는 방법은 여러가지 방법이 있겠지만 가장 직관적인 트릭은 n을 int에서 str으로 바꿔서 각 자릿수를 따로 받은 뒤 다시 int로 변경하는 것이다. 다만 직관적이라고 해서 컴퓨터 내에서 계산이 효율적인지는 모르겠다.

코드는 다음과 같다.



```python
limit = 10000
arrs = [True for _ in range(limit)] # 1~10000을 모두 True로 설정

def selfnumber(n):
    ans = n #d(n) = n + 각 자리수
    for i in str(n):
        ans += int(i) #각 자리수를 더한다.
    return ans

for i in range(limit):
    sn = selfnumber(i+1)
    if sn <= limit:
        arrs[sn-1] = False#생성자를 가진 수는 False로 변경
    if arrs[i]:#만약 생성자를 가지지 않는다면
        print(i+1)#출력
```




반대로 생성자를 가지는지 아닌지를 찾는 함수를 만들어야 한다면 고민을 좀 더 해봐야 할 것 같다. 하지만 메모리와 시간이 허락한다면 굳이 어렵게 코딩을 할 것 없다. 이후에 생각이 난다면 이 포스트에 추가하도록 하겠다.







