---
title: 3052) 나머지
tags: ProgramingStudy
---

[3052](https://www.acmicpc.net/problem/3052)


제목 : 더하기 사이클

- 문제 : 0보다 크거나 같고, 99보다 작거나 같은 정수가 주어질 때 다음과 같은 연산을 할 수 있다. 먼저 주어진 수가 10보다 작다면 앞에 0을 붙여 두 자리 수로 만들고, 각 자리의 숫자를 더한다. 그 다음, 주어진 수의 가장 오른쪽 자리 수와 앞에서 구한 합의 가장 오른쪽 자리 수를 이어 붙이면 새로운 수를 만들 수 있다. 다음 예를 보자.

26부터 시작한다. 2+6 = 8이다. 새로운 수는 68이다. 6+8 = 14이다. 새로운 수는 84이다. 8+4 = 12이다. 새로운 수는 42이다. 4+2 = 6이다. 새로운 수는 26이다.

위의 예는 4번만에 원래 수로 돌아올 수 있다. 따라서 26의 사이클의 길이는 4이다.

N이 주어졌을 때, N의 사이클의 길이를 구하는 프로그램을 작성하시오.
- 입력 : 첫째 줄에 N이 주어진다. N은 0보다 크거나 같고, 99보다 작거나 같은 정수이다.
- 출력 : 첫째 줄에 N의 사이클 길이를 출력한다.

while 문을 잘 활용하면 간단하게 풀 수 있는 쉬운 난이도(브론즈 1)의 문제이다. 참고로 브론즈 문제들은 나같이 코딩에 대해 따로 수업을 듣지 않은 사람도 언어만 써봤다면 짧은 시간내에 풀 수 있는 수준을 가지고 있다.

이 문제에서는 주어진 수 N의 1의 자릿수를 새로운 수의 10의 자리로
주어진 N의 각 자릿수를 더하여 나온 수의 1의 자릿수를 1의 자리로
계산한다.
이를 반복하여 원래 N이 나올 때 까지 걸린 계산횟수를 출력하면 된다.

조금 복잡하지만 주어진 예시를 차근차근 보면 이해가 된다.

26으로 시작하였을 때, 1의 자리는 6이기 때문에 새로운 수의 10의 자리는 6이다.
각 자릿수를 더하면 2+6=8이므로 새로운 수의 1의 자리는 8이다.
결과적으로 26 > 68 로 넘어가게 되며 계산 횟수는 1회 추가된다.

이를 반복하여 원래 수 였던 26이 나오는데는 4번의 계산이 필요하다.
26 > 68 > 184 > 42 > 26

코드는 다음과 같다.

{% highlight python %}

import sys
n0 = int(sys.stdin.readline())#n0에 최초의 n을 저장
n = n0#n에 n0를 복사하여 계산에 사용
a = -1#n과 비교할 새로운 수, 계산과정에서 음수는 절대 나오지 않기 때문에 while문을 위해 -1로 설정

cycle = 0# 계산을 한 번 할 때마다 1씩 추가

while a!=n0:
    a = (n%10)*10 + (n//10 + n%10)%10 #새로운 수 계산
    n = a # 새로운 수를 다음 계산을 위해 복사
    cycle+=1 # 계산 횟수 1회 추가
print(cycle) # 총 계산 횟수 출력


{% endhighlight %}

주석을 참고하면 그리 어려운 계산과정도 아니고, 코드도 굉장히 직관적(비효율적)으로 썻기 때문에 이해가 어렵지 않다.
반복작업을 하고싶지만 반복횟수가 정해지지 않은 경우 while문을 사용하면 된다.(반복횟수가 정해져있다면 간단히 for문을 사용하면 된다)
다만 while문을 사용해보면 알겠지만 while에 거는 조건을 설정하기가 쉽지 않은 경우가 많다. 그렇기 때문에 이 조건만 해결하면 while문을 설계하는건 의외로 쉬운 편이다.

사실 연구과정에선 while을 쓸 일이 그리 많지 않았는데 그 이유는 아무래도 계산 횟수가 정해진 일이 대부분이기 때문에...








